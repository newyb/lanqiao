   /*这里我们来讨论一下用“筛法”来解决这个问题。
　　　先来举个简单的例子来介绍一下“筛法”，求2~20的质数，它的做法是先把2~20这些数一字排开：
　　　2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
　　　先取出数组中最小的数，是2，则判断2是质数，把后面2的倍数全部删掉。
　　　2 | 3 5 7 9 11 13 15 17 19
　　　接下来的最小数是3，取出，再删掉3的倍数
　　　2 3 | 5 7 11 13 17 19
　　　一直这样下去，直到结束。剩下的数都是素数。
　　　筛法的原理是：
　　　1.数字2是素数。
　　　2.在数字K前，每找到一个素数，都会删除它的倍数，即以它为因子的整数。
        如果k未被删除，就表示2->k-1都不是k的因子，那k自然就是素数了。
　　　(1)除余法那篇文章里也介绍了，要找出一个数的因子，其实不需要检查2->k，
只要从2->sqrt(k)，就可以了。所有，我们筛法里，其实只要筛到sqrt(n)就已经找出所有的素数了，其中n为要搜索的范围。
　　　(2)另外，我们不难发现，每找到一个素数k，就一次删除2k, 3k, 4k,..., ik，不免还是有些浪费，
因为2k已经在找到素数2的时候删除过了，3k已经在找到素数3的时候删除了。因此，当i＜k时，
都已经被前面的素数删除过了，只有那些最小的质因子是k的那些数还未被删除过，所有，就可以直接从k*k开始删除。
　　　(3)再有，所有的素数中，除了2以外，其他的都是奇数，那么，当i时奇数的时候
，ik就是奇数，此时k*k+ik就是个偶数，偶数已经被2删除了，
所有我们就可以以2k为单位删除步长，依次删除k*k, k*k+2k, k*k+4k, ...。
  */


import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		ArrayList sushu = new ArrayList();
		for (int i = 2; i < b; i++) {
			boolean flag = true;
			for (int j = 2; j <=Math.sqrt(i); j++)
				if (i % j == 0)
					flag = false;
			if (flag)
				sushu.add(i);
		}
		System.out.print(sushu.get(0));
		for(int i=a;i<=b;i++)
			for(int j=0;j<=sushu.size();j++){
				int s=Integer.parseInt(sushu.get(j).toString());
				if(i%s==0)
					System.out.printf("%dhh%d",i,s);
	}
}}